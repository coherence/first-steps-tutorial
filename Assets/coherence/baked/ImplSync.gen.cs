// Copyright (c) coherence ApS.
// For all coherence generated code, the coherence SDK license terms apply. See the license file in the coherence Package root folder for more information.

// <auto-generated>
// Generated file. DO NOT EDIT!
// </auto-generated>
namespace Coherence.Toolkit
{
	using UnityEngine;
	using System;
	using System.Collections.Generic;
	using global::Coherence.Generated;
	using Coherence.Entity;
	using Coherence.ProtocolDef;
	using Log;
	using Logger = Log.Logger;

	public class CoherenceSyncImpl
	{
		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		static void OnRuntimeMethodLoad()
		{
			Impl.ComponentNameFromTypeId = ComponentNameFromTypeId;
			Impl.CreateInitialComponents = CreateInitialComponents;
			Impl.ReceiveGenericCommand = ReceiveGenericCommand;
			Impl.ReceiveInternalCommand = ReceiveInternalCommand;
			Impl.SendGenericCommand = SendGenericCommand;
			Impl.CreateConnectedEntityUpdateInternal = CreateConnectedEntityUpdateInternal;
			Impl.GetConnectedEntityComponentIdInternal = GetConnectedEntityComponentIdInternal;
			Impl.UpdateTag = UpdateTag;
			Impl.RemoveTag = RemoveTag;
		}

		private static string ComponentNameFromTypeId(uint componentTypeId)
		{
			var componentName = Definition.ComponentNameForTypeId(componentTypeId);

			if (string.IsNullOrEmpty(componentName))
			{
				throw new Exception($"Unhandled component type id: {componentTypeId}");
			}

			return componentName;
		}

		private static ICoherenceComponentData[] CreateInitialComponents(ICoherenceSync self, string uuid)
		{
			var comps = new List<ICoherenceComponentData>();
			comps.Add(new WorldPosition() { value = self.coherencePosition });

			comps.Add(new AssetId() { value = self.CoherenceSyncConfig.ID });

			if (!string.IsNullOrEmpty(uuid))
			{
				comps.Add(new UniqueID() { uuid = uuid });
			}

			if (self.LifetimeTypeConfig != CoherenceSync.LifetimeType.SessionBased)
			{
				comps.Add(new Persistence());
			}

			if (self.PreserveChildren)
			{
				comps.Add(new PreserveChildren());
			}

			return comps.ToArray();
		}

		private static void SendGenericCommand(ICoherenceSync self, IClient client, string commandName, MessageTarget messageTarget, byte[] data, SerializeEntityID[] entityIDs, Logger logger)
		{
			SerializeEntityID targetEntity = self.EntityState.EntityID;

			if (messageTarget == MessageTarget.AuthorityOnly && client.HasAuthorityOverEntity(targetEntity, AuthorityType.State))
			{
				logger.Warning($"Can't send {MessageTarget.AuthorityOnly} command to entity that is owned. Command={commandName} EntityId={targetEntity}");
				return;
			}

			if (!client.EntityExists(targetEntity))
			{
				logger.Warning($"Can't send command to entity that doesn't exist. Command={commandName} EntityId={targetEntity}");
				return;
			}

			if (entityIDs.Length > GenericNetworkCommandArgs.MAX_ENTITY_REFS)
			{
				logger.Warning($"Can't send command that has more than {GenericNetworkCommandArgs.MAX_ENTITY_REFS} entityID parameters. Command={commandName} EntityId={targetEntity}");
				return;
			}

			var sIDs = new SerializeEntityID[GenericNetworkCommandArgs.MAX_ENTITY_REFS];
			if (entityIDs != null)
			{
				for (int i = 0; i < entityIDs.Length; i++)
				{
					sIDs[i] = entityIDs[i];
				}
			}

			var command = new GenericCommand
			{
				name = String.IsNullOrEmpty(commandName) ? "" : commandName,
				commandData = data,
				entityParam1 = sIDs[0],
				entityParam2 = sIDs[1],
				entityParam3 = sIDs[2],
				entityParam4 = sIDs[3],
			};

			client.SendCommand(command, messageTarget, targetEntity);
		}

		private static void ReceiveGenericCommand(ICoherenceSync self, IEntityCommand command, MessageTarget target, Logger logger)
		{
			if (!(command is GenericCommand))
			{
				logger.Warning($"[coherenceSync] Received unknown type of command in reflected mode: {command.GetType()}. {self}");
				return;
			}

			var genericCommand = (GenericCommand)command;
			var commandName = genericCommand.name;
			var commandData = genericCommand.commandData;
			var entityIDs = new SerializeEntityID[GenericNetworkCommandArgs.MAX_ENTITY_REFS];
			entityIDs[0] = genericCommand.entityParam1;
			entityIDs[1] = genericCommand.entityParam2;
			entityIDs[2] = genericCommand.entityParam3;
			entityIDs[3] = genericCommand.entityParam4;

			self.ProcessGenericNetworkCommand(commandName, target, commandData, entityIDs);
		}

		/// <summary>Handles internal commands.</summary>
		/// <returns>
		///     True if the commands was handled. False if the command was not an internal command and should be processed
		///     further.
		/// </returns>
		private static bool ReceiveInternalCommand(CoherenceBridge.EventsToken events, IEntityCommand command,
			Logger logger)
		{
			switch (command)
			{
				case QuerySynced querySynced:
					events.OnQuerySynced((querySynced.liveQuerySynced, querySynced.globalQuerySynced));
					return true;
				default:
					return false;
			}
		}

		private static ICoherenceComponentData CreateConnectedEntityUpdateInternal(SerializeEntityID parentID, Vector3 newPos, Quaternion newRot, Vector3 newScale)
		{
			var comp = new ConnectedEntity()
			{
				value = parentID,
				pos = newPos,
				rot = newRot,
				scale = newScale,
			};

			return comp;
		}

		private static uint GetConnectedEntityComponentIdInternal()
		{
			return Definition.InternalConnectedEntity;
		}

		private static void UpdateTag(IClient client, SerializeEntityID liveQuery, string tag)
		{
			var components = new ICoherenceComponentData[]
			{
				new Tag { tag = tag }
			};

			var masks = new uint[]
			{
				0b01,
			};

			client.UpdateComponents(liveQuery, components, masks);
		}

		private static void RemoveTag(IClient client, SerializeEntityID liveQuery)
		{
			client.RemoveComponents(liveQuery, new []{Definition.InternalTag});
		}
	}
}
