// Copyright (c) coherence ApS.
// For all coherence generated code, the coherence SDK license terms apply. See the license file in the coherence Package root folder for more information.

// <auto-generated>
// Generated file. DO NOT EDIT!
// </auto-generated>
namespace Coherence.Generated
{
    using UnityEngine;
    using Coherence.Toolkit;
    using System;
    using Coherence.ProtocolDef;
    using System.Collections.Generic;
    using Log;
    using Logger = Log.Logger;
    using Coherence.Entities;
    using Coherence.SimulationFrame;
    
    public class CoherenceSyncImpl
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        static void OnRuntimeMethodLoad()
        {
            Impl.ComponentNameFromTypeId = ComponentNameFromTypeId;
            Impl.CreateInitialComponents = CreateInitialComponents;
            Impl.ReceiveGenericCommand = ReceiveGenericCommand;
            Impl.ReceiveInternalCommand = ReceiveInternalCommand;
            Impl.SendGenericCommand = SendGenericCommand;
            Impl.CreateConnectedEntityUpdateInternal = CreateConnectedEntityUpdateInternal;
            Impl.GetConnectedEntityComponentIdInternal = GetConnectedEntityComponentIdInternal;
            Impl.UpdateTag = UpdateTag;
            Impl.RemoveTag = RemoveTag;
        }

        private static string ComponentNameFromTypeId(uint componentTypeId)
        {
            var componentName = Definition.ComponentNameForTypeId(componentTypeId);

            if (string.IsNullOrEmpty(componentName))
            {
                throw new Exception($"Unhandled component type id: {componentTypeId}");
            }

            return componentName;
        }

        private static ICoherenceComponentData[] CreateInitialComponents(ICoherenceSync self, string uuid, bool isFromGroup, AbsoluteSimulationFrame simFrame)
        {
            var comps = new List<ICoherenceComponentData>();
            comps.Add(new WorldPosition() 
            { 
                value = self.coherencePosition, 
                valueSimulationFrame = simFrame, 
                FieldsMask = 0b1, 
            });

            comps.Add(new AssetId() 
            { 
                value = self.CoherenceSyncConfig.ID.GetHashCode(), 
                isFromGroup = isFromGroup, 
                valueSimulationFrame = simFrame,
                isFromGroupSimulationFrame = simFrame,
                FieldsMask = 0b11, 
            });

            if (!string.IsNullOrEmpty(uuid))
            {
                comps.Add(new UniqueID() 
                { 
                    uuid = uuid, 
                    uuidSimulationFrame = simFrame, 
                    FieldsMask = 0b1, 
                });
            }

            if (self.LifetimeTypeConfig != CoherenceSync.LifetimeType.SessionBased)
            {
                comps.Add(new Persistence());
            }

            if (self.PreserveChildren)
            {
                comps.Add(new PreserveChildren());
            }

            return comps.ToArray();
        }

        private static void SendGenericCommand(ICoherenceSync self, IClient client, string commandName, MessageTarget messageTarget, ChannelID channelID, byte[] data, Entity[] entityIDs, Logger logger)
        {
            Entity targetEntity = self.EntityState.EntityID;

            if (messageTarget == MessageTarget.AuthorityOnly && client.HasAuthorityOverEntity(targetEntity, AuthorityType.State))
            {
                logger.Warning(Coherence.Log.Warning.ToolkitGenericCommandSendToOwned,
                    $"Can't send {MessageTarget.AuthorityOnly} command to entity that is owned. Command={commandName} EntityId={targetEntity}");
                return;
            }

            if (!client.EntityExists(targetEntity))
            {
                logger.Warning(Coherence.Log.Warning.ToolkitGenericCommandSendNotExist,
                    $"Can't send command to entity that doesn't exist. Command={commandName} EntityId={targetEntity}");
                return;
            }

            if (entityIDs.Length > GenericNetworkCommandArgs.MAX_ENTITY_REFS)
            {
                logger.Warning(Coherence.Log.Warning.ToolkitGenericCommandSendMaxRefs,
                    $"Can't send command that has more than {GenericNetworkCommandArgs.MAX_ENTITY_REFS} entityID parameters. Command={commandName} EntityId={targetEntity}");
                return;
            }

            var sIDs = new Entity[GenericNetworkCommandArgs.MAX_ENTITY_REFS];
            if (entityIDs != null)
            {
                for (int i = 0; i < entityIDs.Length; i++)
                {
                    sIDs[i] = entityIDs[i];
                }
            }

            var command = new GenericCommand
            {
                name = String.IsNullOrEmpty(commandName) ? "" : commandName,
                commandData = data,
                entityParam1 = sIDs[0],
                entityParam2 = sIDs[1],
                entityParam3 = sIDs[2],
                entityParam4 = sIDs[3],
            };

            client.SendCommand(command, messageTarget, targetEntity, channelID);
        }

        private static void ReceiveGenericCommand(ICoherenceSync self, IEntityCommand command, MessageTarget target, Logger logger)
        {
            if (!(command is GenericCommand))
            {
                logger.Warning(Coherence.Log.Warning.ToolkitGenericMessageReceiveUnknown,
                    $"[coherenceSync] Received unknown type of command in reflected mode: {command.GetType()}. {self}");
                return;
            }

            var genericCommand = (GenericCommand)command;
            var commandName = genericCommand.name;
            var commandData = genericCommand.commandData;
            var entityIDs = new Entity[GenericNetworkCommandArgs.MAX_ENTITY_REFS];
            entityIDs[0] = genericCommand.entityParam1;
            entityIDs[1] = genericCommand.entityParam2;
            entityIDs[2] = genericCommand.entityParam3;
            entityIDs[3] = genericCommand.entityParam4;

            self.ProcessGenericNetworkCommand(commandName, target, commandData, entityIDs);
        }

        /// <summary>Handles internal commands.</summary>
        /// <returns>
        ///     True if the commands was handled. False if the command was not an internal command and should be processed
        ///     further.
        /// </returns>
        private static bool ReceiveInternalCommand(CoherenceBridge.EventsToken events, IEntityCommand command,
            Logger logger)
        {
            switch (command)
            {
                case QuerySynced querySynced:
                    events.OnQuerySynced((querySynced.liveQuerySynced, querySynced.globalQuerySynced));
                    return true;
                default:
                    return false;
            }
        }

        private static ICoherenceComponentData CreateConnectedEntityUpdateInternal(Entity parentID, Vector3 newPos, Quaternion newRot, Vector3 newScale, AbsoluteSimulationFrame simFrame)
        {
            var comp = new ConnectedEntity()
            {
                value = parentID,
                pos = newPos,
                rot = newRot,
                scale = newScale,
                valueSimulationFrame = simFrame,
                posSimulationFrame = simFrame,
                rotSimulationFrame = simFrame,
                scaleSimulationFrame = simFrame,
                FieldsMask = 0b1111,
            };

            return comp;
        }

        private static uint GetConnectedEntityComponentIdInternal()
        {
            return Definition.InternalConnectedEntity;
        }

        private static void UpdateTag(IClient client, Entity liveQuery, string tag, AbsoluteSimulationFrame simFrame)
        {
            var components = new ICoherenceComponentData[]
            {
                new Tag 
                { 
                    tag = tag,
                    tagSimulationFrame = simFrame,
                    FieldsMask = 0b1
                }
            };

            client.UpdateComponents(liveQuery, components);
        }

        private static void RemoveTag(IClient client, Entity liveQuery)
        {
            client.RemoveComponents(liveQuery, new []{Definition.InternalTag});
        }
    }
}
